local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer

-- === SETTINGS ===
local quizActive = false
local selectedCategory = nil
local currentQuestionIndex = 1
local questionTimer = 10
local cooldown = 2
local lastSendTime = 0
local scores = {}
local categories = {}

-- === CATEGORY SETUP ===
categories["Math"] = {
    {
        question = "What is the derivative of x^2?",
        options = {A = "2x", B = "x", C = "x^2", D = "1"},
        answer = "A"
    }
}
categories["Science"] = {
    {
        question = "What planet is known as the Red Planet?",
        options = {A = "Earth", B = "Mars", C = "Venus", D = "Jupiter"},
        answer = "B"
    }
}
categories["English"] = {
    {
        question = "Which is a synonym of 'quick'?",
        options = {A = "Slow", B = "Bright", C = "Fast", D = "Dull"},
        answer = "C"
    }
}
-- Add 1 question for each other category here...

-- === UTILITIES ===
local function notify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = 5
        })
    end)
end

local function sendSystemMessage(message)
    if TextChatService:FindFirstChild("TextChannels") and TextChatService.TextChannels:FindFirstChild("RBXGeneral") then
        TextChatService.TextChannels.RBXGeneral:SendAsync("[Quiz Bot] " .. message)
    end
end

local function showCommands()
    notify("Quiz Bot Commands", "/startquiz - Start quiz\n/stopquiz - Stop quiz")
    sendSystemMessage("Available Commands:\n/startquiz - Start a new quiz\n/stopquiz - Stop the current quiz")
end

-- === QUIZ FLOW ===
local function askNextQuestion()
    if not selectedCategory then return end
    local questions = categories[selectedCategory]
    local question = questions[currentQuestionIndex]
    if not question then
        sendSystemMessage("üéâ Quiz ended! Here are the results:")
        local sorted = {}
        for name, pts in pairs(scores) do
            table.insert(sorted, {name = name, points = pts})
        end
        table.sort(sorted, function(a, b) return a.points > b.points end)
        if sorted[1] then sendSystemMessage("ü•á " .. sorted[1].name .. " (" .. sorted[1].points .. ")") end
        if sorted[2] then sendSystemMessage("ü•à " .. sorted[2].name .. " (" .. sorted[2].points .. ")") end
        if sorted[3] then sendSystemMessage("ü•â " .. sorted[3].name .. " (" .. sorted[3].points .. ")") end
        quizActive = false
        return
    end

    sendSystemMessage("Question " .. currentQuestionIndex .. ": " .. question.question)
    for k, v in pairs(question.options) do
        sendSystemMessage(k .. ") " .. v)
    end

    local answered = false
    local correctAnswer = question.answer
    local correctText = question.options[correctAnswer]

    task.delay(questionTimer, function()
        if not answered and quizActive then
            sendSystemMessage("‚è∞ Time's up! The correct answer was: " .. correctAnswer .. ") " .. correctText)
            currentQuestionIndex += 1
            askNextQuestion()
        end
    end)

    local function handleAnswer(msg, sender)
        if not quizActive then return end
        if answered then return end
        local msgLower = msg:lower()
        local answer = correctAnswer:lower()
        local full = correctText:lower()

        if msgLower == answer or msgLower == full then
            answered = true
            scores[sender.Name] = (scores[sender.Name] or 0) + 1
            sendSystemMessage("‚úÖ " .. sender.Name .. " got it right! Total: " .. scores[sender.Name])
            currentQuestionIndex += 1
            askNextQuestion()
        end
    end

    TextChatService.MessageReceived:Once(function(message)
        local sender = Players:GetPlayerByUserId(message.TextSource.UserId)
        if sender then
            handleAnswer(message.Text, sender)
        end
    end)
end

-- === COMMANDS ===
local function onChat(msg)
    local msgLower = msg:lower()

    if msgLower == "/startquiz" then
        if quizActive then
            sendSystemMessage("Quiz already active!")
            return
        end
        quizActive = true
        scores = {}
        currentQuestionIndex = 1
        selectedCategory = nil

        -- List categories
        local list = "Pick a category:\n"
        local i = 1
        local indexMap = {}
        for name, _ in pairs(categories) do
            list = list .. i .. ") " .. name .. "\n"
            indexMap[tostring(i)] = name
            i += 1
        end
        sendSystemMessage(list)

        -- Wait for someone to pick
        TextChatService.MessageReceived:Once(function(message)
            local pick = indexMap[message.Text]
            if pick then
                selectedCategory = pick
                sendSystemMessage("üìö Starting quiz in: " .. selectedCategory)
                task.wait(2)
                askNextQuestion()
            else
                sendSystemMessage("‚ùå Invalid category or no one picked. Quiz cancelled.")
                quizActive = false
            end
        end)

    elseif msgLower == "/stopquiz" then
        if not quizActive then
            sendSystemMessage("No quiz is running.")
            return
        end
        quizActive = false
        sendSystemMessage("üõë Quiz has been stopped.")
    end
end

-- === CHAT LISTENER ===
TextChatService.MessageReceived:Connect(function(msg)
    if msg.TextSource and msg.TextSource.UserId == player.UserId then
        onChat(msg.Text)
    end
end)

-- === START ===
showCommands()
